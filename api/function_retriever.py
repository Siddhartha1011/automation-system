import chromadb
from chromadb.utils import embedding_functions
from typing import Dict, List, Callable
import inspect
import json
from automation_registry import AutomationRegistry  # Your previous module

class FunctionRetriever:
    """
    Lightweight LLM + RAG system for retrieving automation functions
    """
    
    def __init__(self):
        # Use ChromaDB's default embedding model (avoids heavy dependencies)
        self.embedding_function = embedding_functions.DefaultEmbeddingFunction()
        
        # Initialize ChromaDB
        self.client = chromadb.PersistentClient(path="function_db")
        self.collection = self.client.get_or_create_collection(
            name="functions",
            embedding_function=self.embedding_function
        )
        
        # Initialize automation registry
        self.registry = AutomationRegistry()
        
        # Store function metadata and index them
        self._index_functions()

    def _get_function_metadata(self, func: Callable) -> Dict:
        """Extract metadata from a function"""
        doc = inspect.getdoc(func) or ""
        return {
            "name": func.__name__,
            "description": doc.split('\n')[0] if doc else "",
            "full_description": doc,
            "module": func.__module__,
            "signature": str(inspect.signature(func))
        }

    def _index_functions(self):
        """Index all functions from the AutomationRegistry"""
        functions = [m for m in dir(self.registry) 
                   if not m.startswith('_') and callable(getattr(self.registry, m))]
        
        # Check if collection is empty
        if self.collection.count() == 0:
            print("Indexing functions...")
            metadatas = []
            ids = []
            documents = []
            
            for func_name in functions:
                func = getattr(self.registry, func_name)
                metadata = self._get_function_metadata(func)
                
                # Create document for embedding
                doc_text = f"{func_name}: {metadata['description']}. {metadata['full_description']}"
                
                metadatas.append(metadata)
                ids.append(func_name)
                documents.append(doc_text)
            
            self.collection.add(
                documents=documents,
                metadatas=metadatas,
                ids=ids
            )
            print(f"Indexed {len(functions)} functions")

    def retrieve_function(self, query: str, top_k: int = 3) -> List[Dict]:
        """Retrieve the most relevant functions for a natural language query"""
        # Search in ChromaDB
        results = self.collection.query(
            query_texts=[query],
            n_results=top_k,
            include=["metadatas", "documents", "distances"]
        )
        
        # Format results
        retrieved_functions = []
        for i in range(len(results['ids'][0])):
            func_name = results['ids'][0][i]
            retrieved_functions.append({
                "name": func_name,
                "metadata": results['metadatas'][0][i],
                "score": 1 - results['distances'][0][i],  # Convert distance to similarity
                "function": getattr(self.registry, func_name)
            })
        
        return retrieved_functions

    def generate_script(self, query: str) -> str:
        """Generate executable Python code for a given natural language query"""
        results = self.retrieve_function(query, top_k=1)
        if not results:
            raise ValueError(f"No matching function found for query: '{query}'")
        
        best_match = results[0]
        func_name = best_match['name']
        description = best_match['metadata']['description']
        
        # Generate human-readable success message
        action = description.lower().split('open')[-1].split(' ')[0].strip()
        success_message = f"{action.capitalize()} opened successfully." if action else "Operation completed successfully."

        return f"""# Auto-generated by FunctionRetriever
from automation_registry import AutomationRegistry

def main():
    try:
        AutomationRegistry.{func_name}()
        print("{success_message}")
    except Exception as e:
        print(f"ERROR: {{e}}")
        return 1
    return 0

if __name__ == "__main__":
    import sys
    sys.exit(main())
"""

    def generate_and_execute(self, query: str) -> None:
        """Generate and immediately execute the script"""
        script = self.generate_script(query)
        try:
            exec(script, globals(), locals())
        except Exception as e:
            print(f"Execution failed: {e}")

if __name__ == "__main__":
    retriever = FunctionRetriever()
    
    # Example: Generate and show script
    query = "Launch Google Chrome"
    print(f"\nGenerated script for '{query}':")
    print(retriever.generate_script(query))
    
    # Example: Directly generate and execute
    print("\nExecuting generated script for 'Open calculator':")
    retriever.generate_and_execute("Open calculator")